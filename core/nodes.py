"""
Ëá™ÂÆö‰πâËäÇÁÇπÁ±ªÊ®°Âùó - Êâ©Â±ï LlamaIndex ÁöÑ TextNode
"""

import json
from typing import List, Dict, Any, Optional
from llama_index.core.schema import TextNode, NodeRelationship, RelatedNodeInfo

class ConceptNode(TextNode):
    """Êâ©Â±ï LlamaIndex ÁöÑ TextNode Êù•Ë°®Á§∫Ê¶ÇÂøµ"""
    
    def __init__(self, 
                 concept_text: str, 
                 concept_name: str = None,
                 definition: str = None,
                 source_chunks: List[str] = None, 
                 confidence_score: float = 0.0,
                 keywords: List[str] = None,
                 category: str = None,
                 **kwargs):
        """
        ÂàùÂßãÂåñÊ¶ÇÂøµËäÇÁÇπ
        
        Args:
            concept_text: Ê¶ÇÂøµÊñáÊú¨
            concept_name: Ê¶ÇÂøµÂêçÁß∞
            definition: Ê¶ÇÂøµÂÆö‰πâ
            source_chunks: Êù•Ê∫ê chunk ÂàóË°®
            confidence_score: ÁΩÆ‰ø°Â∫¶ÂàÜÊï∞
            keywords: ÂÖ≥ÈîÆËØçÂàóË°®
            category: Ê¶ÇÂøµÁ±ªÂà´
            **kwargs: ÂÖ∂‰ªñÂèÇÊï∞‰º†ÈÄíÁªôÁà∂Á±ª
        """
        metadata = kwargs.get('metadata', {})
        metadata.update({
            "concept_name": concept_name or concept_text[:50],
            "definition": definition,
            "source_chunks": source_chunks or [],
            "confidence_score": confidence_score,
            "keywords": keywords or [],
            "category": category,
            "node_type": "concept"
        })
        kwargs['metadata'] = metadata
        
        super().__init__(text=concept_text, **kwargs)
    
    @property
    def concept_name(self) -> str:
        return self.metadata.get("concept_name", "")
    
    @property
    def definition(self) -> str:
        return self.metadata.get("definition", "")
    
    @property
    def source_chunks(self) -> List[str]:
        return self.metadata.get("source_chunks", [])
    
    @property
    def confidence_score(self) -> float:
        return self.metadata.get("confidence_score", 0.0)
    
    @property
    def keywords(self) -> List[str]:
        return self.metadata.get("keywords", [])
    
    @property
    def category(self) -> str:
        return self.metadata.get("category", "")
    
    def add_source_chunk(self, chunk: str) -> None:
        """Ê∑ªÂä†Êù•Ê∫êchunk"""
        source_chunks = self.metadata.get("source_chunks", [])
        if chunk not in source_chunks:
            source_chunks.append(chunk)
            self.metadata["source_chunks"] = source_chunks
    
    def add_keyword(self, keyword: str) -> None:
        """Ê∑ªÂä†ÂÖ≥ÈîÆËØç"""
        keywords = self.metadata.get("keywords", [])
        if keyword not in keywords:
            keywords.append(keyword)
            self.metadata["keywords"] = keywords
    
    def to_dict(self) -> Dict[str, Any]:
        """ËΩ¨Êç¢‰∏∫Â≠óÂÖ∏Ê†ºÂºè"""
        return {
            "id": self.node_id,
            "concept_name": self.concept_name,
            "definition": self.definition,
            "text": self.text,
            "source_chunks": self.source_chunks,
            "confidence_score": self.confidence_score,
            "keywords": self.keywords,
            "category": self.category,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ConceptNode':
        """‰ªéÂ≠óÂÖ∏ÂàõÂª∫Ê¶ÇÂøµËäÇÁÇπ"""
        return cls(
            concept_text=data.get("text", ""),
            concept_name=data.get("concept_name"),
            definition=data.get("definition"),
            source_chunks=data.get("source_chunks", []),
            confidence_score=data.get("confidence_score", 0.0),
            keywords=data.get("keywords", []),
            category=data.get("category"),
            node_id=data.get("id")
        )

class EvidenceNode(TextNode):
    """Êâ©Â±ï LlamaIndex ÁöÑ TextNode Êù•Ë°®Á§∫ËØÅÊçÆ"""
    
    def __init__(self, 
                 evidence_text: str, 
                 concept_id: str, 
                 concept_name: str = None,
                 relevance_score: float = 0.0,
                 evidence_type: str = "supporting",
                 source_document: str = None,
                 page_number: int = None,
                 **kwargs):
        """
        ÂàùÂßãÂåñËØÅÊçÆËäÇÁÇπ
        
        Args:
            evidence_text: ËØÅÊçÆÊñáÊú¨
            concept_id: ÂÖ≥ËÅîÁöÑÊ¶ÇÂøµID
            concept_name: ÂÖ≥ËÅîÁöÑÊ¶ÇÂøµÂêçÁß∞
            relevance_score: Áõ∏ÂÖ≥ÊÄßÂàÜÊï∞
            evidence_type: ËØÅÊçÆÁ±ªÂûã (supporting, contradicting, neutral)
            source_document: Êù•Ê∫êÊñáÊ°£
            page_number: È°µÁ†Å
            **kwargs: ÂÖ∂‰ªñÂèÇÊï∞‰º†ÈÄíÁªôÁà∂Á±ª
        """
        metadata = kwargs.get('metadata', {})
        metadata.update({
            "concept_id": concept_id,
            "concept_name": concept_name,
            "relevance_score": relevance_score,
            "evidence_type": evidence_type,
            "source_document": source_document,
            "page_number": page_number,
            "node_type": "evidence"
        })
        kwargs['metadata'] = metadata
        
        super().__init__(text=evidence_text, **kwargs)
        
        # Âª∫Á´ã‰∏éÊ¶ÇÂøµËäÇÁÇπÁöÑÂÖ≥Á≥ª
        if concept_id:
            self.relationships[NodeRelationship.SOURCE] = RelatedNodeInfo(
                node_id=concept_id,
                metadata={"relationship_type": "supports_concept"}
            )
    
    @property
    def concept_id(self) -> str:
        return self.metadata.get("concept_id", "")
    
    @property
    def concept_name(self) -> str:
        return self.metadata.get("concept_name", "")
    
    @property
    def relevance_score(self) -> float:
        return self.metadata.get("relevance_score", 0.0)
    
    @property
    def evidence_type(self) -> str:
        return self.metadata.get("evidence_type", "supporting")
    
    @property
    def source_document(self) -> str:
        return self.metadata.get("source_document", "")
    
    @property
    def page_number(self) -> int:
        return self.metadata.get("page_number", None)
    
    def update_relevance_score(self, score: float) -> None:
        """Êõ¥Êñ∞Áõ∏ÂÖ≥ÊÄßÂàÜÊï∞"""
        score = max(0.0, min(1.0, score))
        self.metadata["relevance_score"] = score
    
    def to_dict(self) -> Dict[str, Any]:
        """ËΩ¨Êç¢‰∏∫Â≠óÂÖ∏Ê†ºÂºè"""
        return {
            "id": self.node_id,
            "text": self.text,
            "concept_id": self.concept_id,
            "concept_name": self.concept_name,
            "relevance_score": self.relevance_score,
            "evidence_type": self.evidence_type,
            "source_document": self.source_document,
            "page_number": self.page_number,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'EvidenceNode':
        """‰ªéÂ≠óÂÖ∏ÂàõÂª∫ËØÅÊçÆËäÇÁÇπ"""
        return cls(
            evidence_text=data.get("text", ""),
            concept_id=data.get("concept_id", ""),
            concept_name=data.get("concept_name"),
            relevance_score=data.get("relevance_score", 0.0),
            evidence_type=data.get("evidence_type", "supporting"),
            source_document=data.get("source_document"),
            page_number=data.get("page_number"),
            node_id=data.get("id")
        )

class QANode(TextNode):
    """Êâ©Â±ï LlamaIndex ÁöÑ TextNode Êù•Ë°®Á§∫ÈóÆÁ≠îÂØπ"""
    
    def __init__(self,
                 question: str,
                 answer: str,
                 concept_id: str = None,
                 concept_name: str = None,
                 difficulty_level: str = "medium",
                 question_type: str = "factual",
                 evidence_ids: List[str] = None,
                 **kwargs):
        """
        ÂàùÂßãÂåñÈóÆÁ≠îËäÇÁÇπ
        
        Args:
            question: ÈóÆÈ¢òÊñáÊú¨
            answer: Á≠îÊ°àÊñáÊú¨
            concept_id: ÂÖ≥ËÅîÁöÑÊ¶ÇÂøµID
            concept_name: ÂÖ≥ËÅîÁöÑÊ¶ÇÂøµÂêçÁß∞
            difficulty_level: ÈöæÂ∫¶Á∫ßÂà´ (easy, medium, hard)
            question_type: ÈóÆÈ¢òÁ±ªÂûã (factual, analytical, creative)
            evidence_ids: ÊîØÊåÅËØÅÊçÆÁöÑIDÂàóË°®
            **kwargs: ÂÖ∂‰ªñÂèÇÊï∞‰º†ÈÄíÁªôÁà∂Á±ª
        """
        qa_text = f"Q: {question}\nA: {answer}"
        
        # üîß ‰øÆÂ§çÔºöÂ∞ÜËá™ÂÆö‰πâÂ±ûÊÄßÂ≠òÂÇ®Âú®metadata‰∏≠
        metadata = kwargs.get('metadata', {})
        metadata.update({
            "question": question,
            "answer": answer,
            "concept_id": concept_id,
            "concept_name": concept_name,
            "difficulty_level": difficulty_level,
            "question_type": question_type,
            "evidence_ids": evidence_ids or [],
            "node_type": "qa"
        })
        kwargs['metadata'] = metadata
        
        super().__init__(text=qa_text, **kwargs)
        
        # ÈóÆÁ≠îÁâπÊúâÂ±ûÊÄß
        self.question = question
        self.answer = answer
        self.concept_id = concept_id
        self.concept_name = concept_name
        self.difficulty_level = difficulty_level
        self.question_type = question_type
        self.evidence_ids = evidence_ids or []
    
    def add_evidence_id(self, evidence_id: str) -> None:
        """Ê∑ªÂä†ÊîØÊåÅËØÅÊçÆID"""
        if evidence_id not in self.evidence_ids:
            self.evidence_ids.append(evidence_id)
            self.metadata["evidence_ids"] = self.evidence_ids
    
    def to_dict(self) -> Dict[str, Any]:
        """ËΩ¨Êç¢‰∏∫Â≠óÂÖ∏Ê†ºÂºè"""
        return {
            "id": self.node_id,
            "question": self.question,
            "answer": self.answer,
            "concept_id": self.concept_id,
            "concept_name": self.concept_name,
            "difficulty_level": self.difficulty_level,
            "question_type": self.question_type,
            "evidence_ids": self.evidence_ids,
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'QANode':
        """‰ªéÂ≠óÂÖ∏ÂàõÂª∫ÈóÆÁ≠îËäÇÁÇπ"""
        return cls(
            question=data.get("question", ""),
            answer=data.get("answer", ""),
            concept_id=data.get("concept_id"),
            concept_name=data.get("concept_name"),
            difficulty_level=data.get("difficulty_level", "medium"),
            question_type=data.get("question_type", "factual"),
            evidence_ids=data.get("evidence_ids", []),
            node_id=data.get("id")
        )

# ËäÇÁÇπÂ∑•ÂéÇÁ±ª
class NodeFactory:
    """ËäÇÁÇπÂ∑•ÂéÇÁ±ªÔºåÁî®‰∫éÂàõÂª∫‰∏çÂêåÁ±ªÂûãÁöÑËäÇÁÇπ"""
    
    @staticmethod
    def create_concept_node(concept_data: Dict[str, Any]) -> ConceptNode:
        """ÂàõÂª∫Ê¶ÇÂøµËäÇÁÇπ"""
        return ConceptNode.from_dict(concept_data)
    
    @staticmethod
    def create_evidence_node(evidence_data: Dict[str, Any]) -> EvidenceNode:
        """ÂàõÂª∫ËØÅÊçÆËäÇÁÇπ"""
        return EvidenceNode.from_dict(evidence_data)
    
    @staticmethod
    def create_qa_node(qa_data: Dict[str, Any]) -> QANode:
        """ÂàõÂª∫ÈóÆÁ≠îËäÇÁÇπ"""
        return QANode.from_dict(qa_data)
    
    @staticmethod
    def create_node_from_type(node_type: str, data: Dict[str, Any]) -> TextNode:
        """Ê†πÊçÆÁ±ªÂûãÂàõÂª∫ËäÇÁÇπ"""
        if node_type == "concept":
            return NodeFactory.create_concept_node(data)
        elif node_type == "evidence":
            return NodeFactory.create_evidence_node(data)
        elif node_type == "qa":
            return NodeFactory.create_qa_node(data)
        else:
            raise ValueError(f"‰∏çÊîØÊåÅÁöÑËäÇÁÇπÁ±ªÂûã: {node_type}") 